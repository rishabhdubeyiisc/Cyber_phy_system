#!/usr/bin/env python3

# Sample python3 code communicating with the shell running on the tiva board.
#
# Note: turn off echo in the shell by removing the following line in the
#       target code:
#    ROM_UARTCharPutNonBlocking(UART0_BASE, ch);     // echo

# Load shell program on the TIVA board.
# Run this code and then reset the TIVA board.

import serial
import datetime
import pytz
import psutil
import time
from influxdb import InfluxDBClient

IFhost = "localhost"
IFport = 8086
IFDbname = 'CPU'

#creating a DB
client = InfluxDBClient(host=IFhost, port=IFport , database=IFDbname)
#creates a Database
#client.create_database(IFDbname)
print(client.get_list_database())

to_run_script= input("press y/Y if DB created : ")
if (to_run_script.lower() != 'y'):
    exit(-99)
client.switch_database(IFDbname)

def write_to_db ( db_client , data_json , ERR_str = ""):
    print(data_json)
    is_data_wr = db_client.write_points(data_json)
    if(not is_data_wr):
        print("ERR : data not written " + ERR_str )


prompt = b'> '

# Find out the virtual com port.
# In Windows, you should see this under Device Manager / Ports.
# In Linux, you should see the tty port by running "dmesg -y".

# In the following example, it is COM3 on Windows, which translates
# to /dev/ttyS3 in WSL.
serial_port = '/dev/ttyACM0'
usb = serial.Serial( serial_port, baudrate=115200, timeout=None)

# Skip greetings and prompt
serial_Din = usb.read_until(prompt)
serial_Din_ascii = serial_Din.decode('ASCII')
print(serial_Din_ascii, end='')


"""
static cmdtable_t CmdTable[] =
{
    {"help", "help: this command \n", doHelp},
    {"led", "led [r|g|b] [on|off] \n", doLed},
	{"readTemp", "readTemp c/f \n", readTemp}
};
"""
# Read command from the stdin
def send_to_shell(shell_command = "readTemp c" , usb_obj = usb):
    serial_Din_ascii = shell_command
    serial_Din_ascii = serial_Din_ascii.replace('\n', '\n\r')
    serial_din = serial_Din_ascii.encode('ASCII')
    usb_obj.write(serial_din)
    usb_obj.write(b'\r')

def read_from_shell(usb_obj = usb):
    # Read the response
    serial_din = usb.read_until(prompt)

    # Remove newlines and prompt
    serial_din = serial_din.replace(b'\n', b'')
    serial_din = serial_din.replace(prompt, b'')
    return serial_din.decode('utf-8')




stabilze = 3
i = 0
while True:
    
    try:
        send_to_shell(shell_command="readTemp c" , usb_obj= usb)
        serial_din = read_from_shell (usb_obj = usb)

        # Print the response and the prompt
        if ( i > stabilze):
            time_stamp = datetime.datetime.now(pytz.utc)
            cpu_usage=psutil.cpu_percent()
            temprature_C = serial_din #.decode('utf-8')
            sensor_data_json =  [
                                    {
                                        'measurement' : 'temperature',
                                        'tags' : {'Sensor' : 'thermal_zone0'},
                                        'time' : time_stamp,
                                        'fields' : {'cputemp' : float(temprature_C)}
                                    }
                                ]
            write_to_db(db_client=client , data_json = sensor_data_json , ERR_str= "SENSOR")

            cpu_data_json = [
                                {
                                    'measurement' : 'usage',
                                    'tags' : {'Sensor' : 'cpu_usage0'},
                                    'time' : time_stamp ,
                                    'fields' : {'cpuusage' : float(cpu_usage)}
                                }
                            ]
            write_to_db(db_client=client , data_json = cpu_data_json , ERR_str = "CPU")
            #sleep
            time.sleep(1)
            continue
        i = i + 1
    except KeyboardInterrupt:
        print("KeyboardInterrupt")
        exit(99)
# end of file
