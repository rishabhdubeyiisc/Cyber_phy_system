#!/usr/bin/env python3

# Sample python3 code communicating with the shell running on the tiva board.
#
# Note: turn off echo in the shell by removing the following line in the
#       target code:
#    ROM_UARTCharPutNonBlocking(UART0_BASE, ch);     // echo

# Load shell program on the TIVA board.
# Run this code and then reset the TIVA board.

import serial
import datetime
import pytz
import psutil
import time
from influxdb import InfluxDBClient

IFhost = "localhost"
IFport = 8086
IFDbname = 'CPU'

#creating a DB
client = InfluxDBClient(host=IFhost, port=IFport , database=IFDbname)
#creates a Database
#client.create_database(IFDbname)
print(client.get_list_database())

to_run_script= input("press y/Y if DB created : ")
if (to_run_script.lower() != 'y'):
    exit(-99)
client.switch_database(IFDbname)


prompt = b'> '

# Find out the virtual com port.
# In Windows, you should see this under Device Manager / Ports.
# In Linux, you should see the tty port by running "dmesg -y".

# In the following example, it is COM3 on Windows, which translates
# to /dev/ttyS3 in WSL.
usb = serial.Serial('/dev/ttyACM0', baudrate=115200, timeout=None)

# Skip greetings and prompt
serial_Din = usb.read_until(prompt)
serial_Din_ascii = serial_Din.decode('ASCII')
print(serial_Din_ascii, end='')

# Read a command from stdin, send it to TIVA and print the response.
stabilze = 3
i = 0
sample_no = 0
""" TODO setup server
cl send req
web sockets (over hhtp)
bi-dir connection
else
timely ping

"""
while True:
    # Read command from the stdin
    serial_Din_ascii = "readTemp c"
    serial_Din_ascii = serial_Din_ascii.replace('\n', '\n\r')
    serial_din = serial_Din_ascii.encode('ASCII')
    usb.write(serial_din)
    usb.write(b'\r')

    # Read the response
    serial_din = usb.read_until(prompt)

    # Remove newlines and prompt
    serial_din = serial_din.replace(b'\n', b'')
    serial_din = serial_din.replace(prompt, b'')

    # Print the response and the prompt
    if ( i > stabilze):
        sample_no = sample_no + 1
        time_stamp = datetime.datetime.now(pytz.utc)
        cpu_usage=psutil.cpu_percent()
        temprature_C = serial_din.decode('utf-8')
        sensor_data_json =  [
                                {
                                    'measurement' : 'temperature',
                                    'tags' : {'Sensor' : 'thermal_zone0'},
                                    'time' : time_stamp,
                                    'fields' : {'cputemp' : float(temprature_C)}
                                }
                            ]
        print(sensor_data_json)
        is_sensor_data_wr = client.write_points(sensor_data_json)
        if(not is_sensor_data_wr):
            print("ERR : sensor data not written")

        cpu_data_json = [
                            {
                                'measurement' : 'usage',
                                'tags' : {'Sensor' : 'cpu_usage0'},
                                'time' : time_stamp ,
                                'fields' : {'cpuusage' : float(cpu_usage)}
                            }
                        ]
        print(cpu_data_json)
        is_cpu_data_wr = client.write_points(cpu_data_json)
        if(not is_cpu_data_wr):
            print("ERR : cpu data not written")
        #time.sleep(1)
        continue
    i = i + 1

# end of file
